{"meta":{"title":"Hexo","subtitle":"","description":"","author":"FengDonghai","url":"http://yoursite.com","root":"/"},"pages":[{"title":"about","date":"2020-04-28T01:33:51.000Z","updated":"2020-04-28T02:31:59.915Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":""},{"title":"分类","date":"2020-04-28T01:26:40.000Z","updated":"2020-04-28T02:25:17.451Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"All tags","date":"2020-04-28T01:35:27.000Z","updated":"2020-04-28T02:25:04.279Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"MFC&Halcon显示图像，平移，缩放","slug":"MFC&Halcon显示图像，平移，缩放","date":"2020-05-06T05:27:14.131Z","updated":"2020-05-06T05:28:20.504Z","comments":true,"path":"2020/05/06/MFC&Halcon显示图像，平移，缩放/","link":"","permalink":"http://yoursite.com/2020/05/06/MFC&Halcon%E6%98%BE%E7%A4%BA%E5%9B%BE%E5%83%8F%EF%BC%8C%E5%B9%B3%E7%A7%BB%EF%BC%8C%E7%BC%A9%E6%94%BE/","excerpt":"","text":"在MFC图片控件中利用Halcon函数库实现图片读取、保存是比较基本的操作。将图片控件句柄传入Halcon打开窗口”open_window”函数后，MFC无法正常响应鼠标消息。此时需要使用MFC“PreTranslateMessage”来获取鼠标坐标。利用Halcon “SetPart” 来设置显示的图像显示范围。 将图片控件句柄传入Halcon打开窗口”open_window”函数后，MFC无法正常响应鼠标消息。此时需要使用MFC“PreTranslateMessage”来获取鼠标坐标。 接下来详细说明下步骤。 1. 在界面上拉取一个静态文本框，用来显示图像并修改文本框的属性-ID: IDC_STATIC_HALCON_IMG &lt;–more–&gt; 2. 声明添加需要用到的变量1234567891011HObject m_hImage;HTuple m_hWidth;HTuple m_hHeight;HTuple hImgWnd;double m_dDispImagePartRow0;double m_dDispImagePartCol0;double m_dDispImagePartRow1;double m_dDispImagePartCol1;HTuple m_hRowB, m_hColB, m_hRowE, m_hColE;int m_iCursor;//按下左键，滚轮滚动double m_dXO, m_dYO; 3. 初始化，创建Halcon窗口并绑定ID，显示图像1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950BOOL CPUTTEXT::OnInitDialog()&#123; CDialogEx::OnInitDialog(); // TODO: 在此添加额外的初始化 CRect m_rtImage; GetDlgItem(IDC_STATIC_HALCON_IMG)-&gt;GetClientRect(&amp;m_rtImage);//IDC_DISPIMAGE为第一个图像控件的ID号，第二个窗口类似处理。 HWND hWnd; SetCheck(\"~father\"); hWnd = GetDlgItem(IDC_STATIC_HALCON_IMG)-&gt;m_hWnd; SetWindowAttr(\"background_color\", \"black\"); OpenWindow(m_rtImage.left, m_rtImage.top, m_rtImage.Width(), m_rtImage.Height(), (Hlong)hWnd, \"visible\", \"\", &amp;hImgWnd); CString strDispImage; strDispImage.Format(\".\\\\res\\\\basic.bmp\"); ReadImage(&amp;m_hImage, (HTuple)strDispImage); DispObj(m_hImage, hImgWnd); GetImageSize(m_hImage, &amp;m_hWidth, &amp;m_hHeight); //设置窗口 float fImage = m_hWidth.D() / m_hHeight.D(); float fWindow = (float)m_rtImage.Width() / m_rtImage.Height(); float Row0 = 0, Col0 = 0, Row1 = m_hHeight - 1, Col1 = m_hWidth - 1; if (fWindow &gt; fImage) &#123; float w = fWindow * m_hHeight; Row0 = 0; Col0 = -(w - m_hWidth) / 2; Row1 = m_hHeight - 1; Col1 = m_hWidth + (w - m_hWidth) / 2; &#125; else &#123; float h = m_hWidth / fWindow; Row0 = -(h - m_hHeight) / 2; Col0 = 0; Row1 = m_hHeight + (h - m_hHeight) / 2; Col1 = m_hWidth - 1; &#125; m_dDispImagePartRow0 = Row0; m_dDispImagePartCol0 = Col0; m_dDispImagePartRow1 = Row1; m_dDispImagePartCol1 = Col1; ShowImage(); return TRUE; // return TRUE unless you set the focus to a control // 异常: OCX 属性页应返回 FALSE&#125; 由于初始化中用到了ShowImage()函数，并且在其他地方会重复使用，因此，单独定义为函数。 123456789101112131415161718void ShowImage()&#123; if (hImgWnd != 0) &#123; SetSystem(\"flush_graphic\", \"false\"); ClearWindow(hImgWnd); //显示 if (m_hImage.IsInitialized()) &#123; SetPart(hImgWnd, m_dDispImagePartRow0, m_dDispImagePartCol0, m_dDispImagePartRow1 - 1, m_dDispImagePartCol1 - 1); DispObj(m_hImage, hImgWnd); &#125; SetSystem(\"flush_graphic\", \"true\"); HObject emptyObject; emptyObject.GenEmptyObj(); DispObj(emptyObject, hImgWnd); &#125;&#125; 4. 鼠标滚轮响应图像缩放123456789101112131415161718192021222324252627282930313233343536373839BOOL CPUTTEXT::OnMouseWheel(UINT nFlags, short zDelta, CPoint pt)&#123; CRect rtImage; GetDlgItem(IDC_STATIC_HALCON_IMG)-&gt;GetWindowRect(&amp;rtImage); if (rtImage.PtInRect(pt) &amp;&amp; m_hImage.IsInitialized()) &#123; Hlong ImagePtX, ImagePtY; Hlong Row0, Col0, Row1, Col1; double Scale = 0.1; if (zDelta &lt; 0) &#123; ImagePtX = m_dDispImagePartCol0 + (pt.x - rtImage.left) / (rtImage.Width() - 1.0)*(m_dDispImagePartCol1 - m_dDispImagePartCol0); ImagePtY = m_dDispImagePartRow0 + (pt.y - rtImage.top) / (rtImage.Height() - 1.0)*(m_dDispImagePartRow1 - m_dDispImagePartRow0); Row0 = ImagePtY - 1 / (1 - Scale)*(ImagePtY - m_dDispImagePartRow0); Row1 = ImagePtY - 1 / (1 - Scale)*(ImagePtY - m_dDispImagePartRow1); Col0 = ImagePtX - 1 / (1 - Scale)*(ImagePtX - m_dDispImagePartCol0); Col1 = ImagePtX - 1 / (1 - Scale)*(ImagePtX - m_dDispImagePartCol1); m_dDispImagePartRow0 = Row0; m_dDispImagePartCol0 = Col0; m_dDispImagePartRow1 = Row1; m_dDispImagePartCol1 = Col1; &#125; else &#123; ImagePtX = m_dDispImagePartCol0 + (pt.x - rtImage.left) / (rtImage.Width() - 1.0)*(m_dDispImagePartCol1 - m_dDispImagePartCol0); ImagePtY = m_dDispImagePartRow0 + (pt.y - rtImage.top) / (rtImage.Height() - 1.0)*(m_dDispImagePartRow1 - m_dDispImagePartRow0); Row0 = ImagePtY - 1 / (1 + Scale)*(ImagePtY - m_dDispImagePartRow0); Row1 = ImagePtY - 1 / (1 + Scale)*(ImagePtY - m_dDispImagePartRow1); Col0 = ImagePtX - 1 / (1 + Scale)*(ImagePtX - m_dDispImagePartCol0); Col1 = ImagePtX - 1 / (1 + Scale)*(ImagePtX - m_dDispImagePartCol1); m_dDispImagePartRow0 = Row0; m_dDispImagePartCol0 = Col0; m_dDispImagePartRow1 = Row1; m_dDispImagePartCol1 = Col1; &#125; ShowImage(); &#125; return CDialogEx::OnMouseWheel(nFlags, zDelta, pt);&#125; 5. 使用消息响应PreTranslateMessage响应图像移动将图片控件句柄传入Halcon打开窗口”open_window”函数后，MFC无法正常响应鼠标消息。此时需要使用MFC“PreTranslateMessage”来获取鼠标坐标。 1234567891011121314151617181920212223242526272829303132333435363738394041424344BOOL CPUTTEXT::PreTranslateMessage(MSG* pMsg)&#123; BOOL m_bImgMove; CRect m_rPic; CPoint point; GetCursorPos(&amp;point); CWnd * phWnd = GetDlgItem(IDC_STATIC_HALCON_IMG); phWnd-&gt;GetClientRect(m_rPic); phWnd-&gt;ClientToScreen(m_rPic); point.x = point.x - m_rPic.left; point.y = point.y - m_rPic.top; phWnd-&gt;GetClientRect(m_rPic); if (m_rPic.PtInRect(point)) //鼠标移动在窗口内 &#123; CPoint point2; point2 = point; if (pMsg-&gt;message == WM_LBUTTONDOWN) //鼠标左键单击 &#123; if (5 == m_iCursor) //图像移动 &#123; m_dXO = point2.x; m_dYO = point2.y; m_bImgMove = true; &#125; &#125; else if (pMsg-&gt;message == WM_LBUTTONUP) &#123; if (5 == m_iCursor) //图像移动 &#123; m_bImgMove = false; MoveWnd(point2, m_hImage, hImgWnd); m_dXO = 0; m_dYO = 0; &#125; &#125; &#125; [if (pMsg-&gt;message == WM_KEYDOWN&amp;&amp;pMsg-&gt;wParam == VK_RETURN) return TRUE; if (pMsg-&gt;message == WM_KEYDOWN&amp;&amp;pMsg-&gt;wParam == VK_ESCAPE) return TRUE;](https://www.notion.so/ESC-730b211b0a6e4c9d88672e27bfee021e) return __super::PreTranslateMessage(pMsg);&#125; 用到了以下函数MoveWnd移动显示函数以及OnMouseMove消息 123456789101112void CPUTTEXT::MoveWnd(CPoint point, HImage srcImg, HTuple hWindow)&#123; double xOffset = point.x - m_dXO; double yOffset = point.y - m_dYO; m_dDispImagePartRow0 = m_dDispImagePartRow0 - yOffset; m_dDispImagePartCol0 = m_dDispImagePartCol0 - xOffset; m_dDispImagePartRow1 = m_dDispImagePartRow1 - yOffset; m_dDispImagePartCol1 = m_dDispImagePartCol1 - xOffset; ClearWindow(hWindow); SetPart(hWindow, m_dDispImagePartRow0, m_dDispImagePartCol0, m_dDispImagePartRow1, m_dDispImagePartCol1); DispImage(srcImg, hWindow);&#125; 12345void CPUTTEXT::OnMouseMove(UINT nFlags, CPoint point)&#123; m_iCursor=5; CDialogEx::OnMouseMove(nFlags, point);&#125; 6. 全部代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185HObject m_hImage;HTuple m_hWidth;HTuple m_hHeight;HTuple hImgWnd;double m_dDispImagePartRow0;double m_dDispImagePartCol0;double m_dDispImagePartRow1;double m_dDispImagePartCol1;HTuple m_hRowB, m_hColB, m_hRowE, m_hColE;int m_iCursor;//按下左键，滚轮滚动double m_dXO, m_dYO;BOOL CPUTTEXT::OnInitDialog()&#123; CDialogEx::OnInitDialog(); // TODO: 在此添加额外的初始化 CRect m_rtImage; GetDlgItem(IDC_STATIC_HALCON_IMG)-&gt;GetClientRect(&amp;m_rtImage);//IDC_DISPIMAGE为第一个图像控件的ID号，第二个窗口类似处理。 HWND hWnd; SetCheck(\"~father\"); hWnd = GetDlgItem(IDC_STATIC_HALCON_IMG)-&gt;m_hWnd; SetWindowAttr(\"background_color\", \"black\"); OpenWindow(m_rtImage.left, m_rtImage.top, m_rtImage.Width(), m_rtImage.Height(), (Hlong)hWnd, \"visible\", \"\", &amp;hImgWnd); ReadImage(&amp;m_hImage, \"C:\\\\Users\\\\15076\\\\Desktop\\\\12121\\\\1.jpg\"); DispObj(m_hImage, hImgWnd); GetImageSize(m_hImage, &amp;m_hWidth, &amp;m_hHeight); //设置窗口 float fImage = m_hWidth.D() / m_hHeight.D(); float fWindow = (float)m_rtImage.Width() / m_rtImage.Height(); float Row0 = 0, Col0 = 0, Row1 = m_hHeight - 1, Col1 = m_hWidth - 1; if (fWindow &gt; fImage) &#123; float w = fWindow * m_hHeight; Row0 = 0; Col0 = -(w - m_hWidth) / 2; Row1 = m_hHeight - 1; Col1 = m_hWidth + (w - m_hWidth) / 2; &#125; else &#123; float h = m_hWidth / fWindow; Row0 = -(h - m_hHeight) / 2; Col0 = 0; Row1 = m_hHeight + (h - m_hHeight) / 2; Col1 = m_hWidth - 1; &#125; m_dDispImagePartRow0 = Row0; m_dDispImagePartCol0 = Col0; m_dDispImagePartRow1 = Row1; m_dDispImagePartCol1 = Col1; ShowImage(); return TRUE; // return TRUE unless you set the focus to a control // 异常: OCX 属性页应返回 FALSE&#125;void ShowImage()&#123; if (hImgWnd != 0) &#123; SetSystem(\"flush_graphic\", \"false\"); ClearWindow(hImgWnd); //显示 if (m_hImage.IsInitialized()) &#123; SetPart(hImgWnd, m_dDispImagePartRow0, m_dDispImagePartCol0, m_dDispImagePartRow1 - 1, m_dDispImagePartCol1 - 1); DispObj(m_hImage, hImgWnd); &#125; SetSystem(\"flush_graphic\", \"true\"); HObject emptyObject; emptyObject.GenEmptyObj(); DispObj(emptyObject, hImgWnd); &#125;&#125;BOOL CPUTTEXT::OnMouseWheel(UINT nFlags, short zDelta, CPoint pt)&#123; // TODO: 在此添加消息处理程序代码和/或调用默认值 CRect rtImage; GetDlgItem(IDC_STATIC_HALCON_IMG)-&gt;GetWindowRect(&amp;rtImage); if (rtImage.PtInRect(pt) &amp;&amp; m_hImage.IsInitialized()) &#123; Hlong ImagePtX, ImagePtY; Hlong Row0, Col0, Row1, Col1; double Scale = 0.1; if (zDelta &lt; 0) &#123; ImagePtX = m_dDispImagePartCol0 + (pt.x - rtImage.left) / (rtImage.Width() - 1.0)*(m_dDispImagePartCol1 - m_dDispImagePartCol0); ImagePtY = m_dDispImagePartRow0 + (pt.y - rtImage.top) / (rtImage.Height() - 1.0)*(m_dDispImagePartRow1 - m_dDispImagePartRow0); Row0 = ImagePtY - 1 / (1 - Scale)*(ImagePtY - m_dDispImagePartRow0); Row1 = ImagePtY - 1 / (1 - Scale)*(ImagePtY - m_dDispImagePartRow1); Col0 = ImagePtX - 1 / (1 - Scale)*(ImagePtX - m_dDispImagePartCol0); Col1 = ImagePtX - 1 / (1 - Scale)*(ImagePtX - m_dDispImagePartCol1); m_dDispImagePartRow0 = Row0; m_dDispImagePartCol0 = Col0; m_dDispImagePartRow1 = Row1; m_dDispImagePartCol1 = Col1; &#125; else &#123; ImagePtX = m_dDispImagePartCol0 + (pt.x - rtImage.left) / (rtImage.Width() - 1.0)*(m_dDispImagePartCol1 - m_dDispImagePartCol0); ImagePtY = m_dDispImagePartRow0 + (pt.y - rtImage.top) / (rtImage.Height() - 1.0)*(m_dDispImagePartRow1 - m_dDispImagePartRow0); Row0 = ImagePtY - 1 / (1 + Scale)*(ImagePtY - m_dDispImagePartRow0); Row1 = ImagePtY - 1 / (1 + Scale)*(ImagePtY - m_dDispImagePartRow1); Col0 = ImagePtX - 1 / (1 + Scale)*(ImagePtX - m_dDispImagePartCol0); Col1 = ImagePtX - 1 / (1 + Scale)*(ImagePtX - m_dDispImagePartCol1); m_dDispImagePartRow0 = Row0; m_dDispImagePartCol0 = Col0; m_dDispImagePartRow1 = Row1; m_dDispImagePartCol1 = Col1; &#125; ShowImage(); &#125; return CDialogEx::OnMouseWheel(nFlags, zDelta, pt);&#125;BOOL CPUTTEXT::PreTranslateMessage(MSG* pMsg)&#123; BOOL m_bImgMove; CRect m_rPic; CPoint point; GetCursorPos(&amp;point); CWnd * phWnd = GetDlgItem(IDC_STATIC_HALCON_IMG); phWnd-&gt;GetClientRect(m_rPic); phWnd-&gt;ClientToScreen(m_rPic); point.x = point.x - m_rPic.left; point.y = point.y - m_rPic.top; phWnd-&gt;GetClientRect(m_rPic); if (m_rPic.PtInRect(point)) //鼠标移动在窗口内 &#123; CPoint point2; point2 = point; if (pMsg-&gt;message == WM_LBUTTONDOWN) //鼠标左键单击 &#123; if (5 == m_iCursor) //图像移动 &#123; m_dXO = point2.x; m_dYO = point2.y; m_bImgMove = true; &#125; &#125; else if (pMsg-&gt;message == WM_LBUTTONUP) &#123; if (5 == m_iCursor) //图像移动 &#123; m_bImgMove = false; MoveWnd(point2, m_hImage, hImgWnd); m_dXO = 0; m_dYO = 0; &#125; &#125; &#125; if (pMsg-&gt;message == WM_KEYDOWN&amp;&amp;pMsg-&gt;wParam == VK_RETURN) return TRUE; if (pMsg-&gt;message == WM_KEYDOWN&amp;&amp;pMsg-&gt;wParam == VK_ESCAPE) return TRUE; return __super::PreTranslateMessage(pMsg);&#125;void CPUTTEXT::MoveWnd(CPoint point, HImage srcImg, HTuple hWindow)&#123; double xOffset = point.x - m_dXO; double yOffset = point.y - m_dYO; m_dDispImagePartRow0 = m_dDispImagePartRow0 - yOffset; m_dDispImagePartCol0 = m_dDispImagePartCol0 - xOffset; m_dDispImagePartRow1 = m_dDispImagePartRow1 - yOffset; m_dDispImagePartCol1 = m_dDispImagePartCol1 - xOffset; ClearWindow(hWindow); SetPart(hWindow, m_dDispImagePartRow0, m_dDispImagePartCol0, m_dDispImagePartRow1, m_dDispImagePartCol1); DispImage(srcImg, hWindow);&#125;void CPUTTEXT::OnMouseMove(UINT nFlags, CPoint point)&#123; m_iCursor=5; CDialogEx::OnMouseMove(nFlags, point);&#125; 7. 参考链接https://blog.csdn.net/qq_39008744/article/details/104956303","categories":[],"tags":[]},{"title":"如何搭建比较“好”的框架","slug":"如何搭建比较“好”的框架","date":"2020-04-27T09:05:49.812Z","updated":"2020-04-27T01:05:04.000Z","comments":true,"path":"2020/04/27/如何搭建比较“好”的框架/","link":"","permalink":"http://yoursite.com/2020/04/27/%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BA%E6%AF%94%E8%BE%83%E2%80%9C%E5%A5%BD%E2%80%9D%E7%9A%84%E6%A1%86%E6%9E%B6/","excerpt":"","text":"如何搭建比较“好”的系统框架先贴上代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;iostream&gt;using namespace std;class A&#123; public: A()&#123;&#125;; virtual ~A()&#123;&#125;; virtual void display()=0; virtual void run()=0;&#125;;class C: public A&#123; public: void display();// 实现类 void run();&#125;;void C::display()// 实现代码 &#123; cout&lt;&lt;\"cc_display\"&lt;&lt;endl;&#125;void C::run() //具体实现 &#123; cout&lt;&lt;\"cc_run\"&lt;&lt;endl;&#125;class B: public A&#123; public: B(); virtual ~B(); A* a; void display(); void run();&#125;;//----------------------------------------//比较统一， 专门用于导出 void B::display() //接口类&#123; a-&gt;display();&#125;void B::run() //接口类&#123; a-&gt;run();&#125;//-----------------------------------------B::B() //构造函数 &#123; a=NULL; a=new C;&#125;B::~B() //析构函数 &#123; delete a; a=NULL;&#125;int main()&#123; A* a; a=new B; a-&gt;display(); a-&gt;run();&#125; 分析： 什么是一个较好的系统？最基本的要求，框架比较稳定，后续的添加需求不能影响到原来的系统框架，以最小的成本实现。当然，具体的可参见，这里仅简要说说。","categories":[],"tags":[]},{"title":"为什么要引入虚函数？","slug":"为什么要引入虚函数？","date":"2020-04-27T05:01:21.925Z","updated":"2020-04-28T02:10:42.035Z","comments":true,"path":"2020/04/27/为什么要引入虚函数？/","link":"","permalink":"http://yoursite.com/2020/04/27/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%BC%95%E5%85%A5%E8%99%9A%E5%87%BD%E6%95%B0%EF%BC%9F/","excerpt":"为什么要引入虚函数？ 虚函数 本文主要介绍虚函数，首先，我们需要了解什么是虚函数，为什么需要虚函数？如何在我们的项目中使用虚函数?虚函数对我们有什么帮助？主要能帮助我们解决哪些问题，又会为我们带来哪些便利？经常应用的场合时什么？在使用过程中，有哪些需要注意的事项？","text":"为什么要引入虚函数？ 虚函数 本文主要介绍虚函数，首先，我们需要了解什么是虚函数，为什么需要虚函数？如何在我们的项目中使用虚函数?虚函数对我们有什么帮助？主要能帮助我们解决哪些问题，又会为我们带来哪些便利？经常应用的场合时什么？在使用过程中，有哪些需要注意的事项？ 代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;iostream&gt;using namespace std;class A&#123; public: virtual void display();&#125;;void A::display()&#123; cout&lt;&lt;\"a\"&lt;&lt;endl;&#125;class B: public A&#123; public: void display();&#125;;void B::display()&#123; cout&lt;&lt;\"b\"&lt;&lt;endl;&#125;class C:public A&#123; void display();&#125;;void C::display()&#123; cout&lt;&lt;\"c\"&lt;&lt;endl;&#125;int main()&#123; A *p; p=new A; //调用成员函数时指针属于谁就调用谁 p-&gt;display();//a p=new B; p-&gt;display();//b p=new C; p-&gt;display(); // c return 0;&#125; 复制这段代码，到http://coliru.stacked-crooked.com/运行一次，看看效果，自己再动手写一遍。","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2020-04-27T01:28:45.698Z","updated":"2020-04-27T01:28:45.698Z","comments":true,"path":"2020/04/27/hello-world/","link":"","permalink":"http://yoursite.com/2020/04/27/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[],"tags":[]}